<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nova Translator | ZOX Robotics</title>
  <style>
    :root {
      --bg: #1e1e2e;
      --panel: #2a2a3e;
      --text: #ffffff;
      --primary: #4e9af1;
      --secondary: #f18b40;
      --highlight: #ffcc00;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .card {
      background: var(--panel);
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      padding: 2rem;
      width: 100%;
      max-width: 500px;
    }
    .card h1 {
      text-align: center;
      margin-bottom: 1rem;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 1.8rem;
    }
    #log { text-align: center; margin-bottom: 1rem; color: var(--highlight); min-height: 1.2em; }
    .row { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    select, textarea {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 1rem;
    }
    textarea { min-height: 100px; resize: none; }
    #output {
      padding: 0.75rem;
      background: var(--bg);
      border-radius: 8px;
      min-height: 80px;
      margin-bottom: 1rem;
    }
    .buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    button {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      background: var(--primary);
      color: var(--text);
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    button.secondary { background: var(--secondary); }
    button.highlight { background: var(--highlight); color: var(--panel); }
    button:hover { opacity: 0.9; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Nova Translator</h1>
    <div id="log">Ready</div>
    <div class="row">
      <select id="inputLang"></select>
      <select id="outputLang"></select>
    </div>
    <textarea id="inputText" placeholder="..."></textarea>
    <div id="output"></div>
    <div class="buttons">
      <button id="translateBtn">Translate</button>
      <button id="micBtn" class="secondary">ðŸŽ¤ Mic</button>
      <button id="speakBtn" class="highlight">ðŸ”Š Speak</button>
      <button id="clearBtn" class="secondary">Clear</button>
      <button id="assistantBtn" class="highlight">Assistant</button>
    </div>
  </div>
  <script>
    const langMap = {
      en: "English", es: "Spanish", fr: "French", de: "German", zh: "Chinese (Simplified)", hi: "Hindi",
      ar: "Arabic", ru: "Russian", ja: "Japanese", pt: "Portuguese", it: "Italian"
    };
    const langCodeMap = {
      en: "en-US", es: "es-ES", fr: "fr-FR", de: "de-DE", zh: "zh-CN", hi: "hi-IN",
      ar: "ar-SA", ru: "ru-RU", ja: "ja-JP", pt: "pt-PT", it: "it-IT"
    };
    const inputLang = document.getElementById('inputLang');
    const outputLang = document.getElementById('outputLang');
    const inputText = document.getElementById('inputText');
    const translatedText = document.getElementById('translatedText');
    const clearBtn = document.getElementById('clearBtn');
    const speakBtn = document.getElementById('speakBtn');
    const autoListenBtn = document.getElementById('autoListenBtn');
  
    let recognition = null;
    let isListening = false;
  
    function startAssistant() {
      if (!('webkitSpeechRecognition' in window)) {
        alert('Speech recognition not supported in this browser.');
        return;
      }
      if (recognition) {
        recognition.abort();
        recognition = null;
      }
      recognition = new webkitSpeechRecognition();
      recognition.lang = langCodeMap[inputLang.value] || "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      isListening = true;
  
      autoListenBtn.textContent = "Assistant Listening... (Click to stop)";
      autoListenBtn.classList.add('active');
      autoListenBtn.disabled = false;
  
      recognition.onresult = async (event) => {
        const spokenText = event.results[0][0].transcript.trim();
        await processVoiceCommand(spokenText);
        if (isListening) {
          waitForSpeechEnd().then(() => {
            if (isListening) setTimeout(() => { try { recognition.start(); } catch{} }, 400);
          });
        }
      };
      recognition.onend = () => {
        if (isListening && !window.speechSynthesis.speaking) {
          setTimeout(() => { try { recognition.start(); } catch{} }, 400);
        }
      };
      recognition.onerror = (event) => {
        if (event.error !== "no-speech" && event.error !== "aborted") {
          alert("Speech error: " + event.error);
        }
        if (isListening) {
          setTimeout(() => { try { recognition.start(); } catch{} }, 700);
        }
      };
      recognition.start();
    }
  
    function stopAssistant() {
      isListening = false;
      if (recognition) recognition.abort();
      autoListenBtn.textContent = "Start Assistant";
      autoListenBtn.classList.remove('active');
      autoListenBtn.disabled = false;
    }
  
    autoListenBtn.onclick = () => {
      if (isListening) {
        stopAssistant();
      } else {
        startAssistant();
      }
    };
  
    function waitForSpeechEnd() {
      return new Promise(resolve => {
        if (!('speechSynthesis' in window)) return resolve();
        if (!window.speechSynthesis.speaking) return resolve();
        let id = setInterval(() => {
          if (!window.speechSynthesis.speaking) {
            clearInterval(id);
            resolve();
          }
        }, 100);
      });
    }
  
    async function processVoiceCommand(spokenText) {
      const fromToRegex = /translate (.+?) from ([a-z]+) to ([a-z]+)/i;
      let match = spokenText.match(fromToRegex);
      if (match) {
        const phrase = match[1].trim();
        const fromLang = match[2];
        const toLang = match[3];
        let fromCode = null, toCode = null;
        for (const [code, name] of Object.entries(langMap)) {
          if (name.toLowerCase().includes(fromLang.toLowerCase())) fromCode = code;
          if (name.toLowerCase().includes(toLang.toLowerCase())) toCode = code;
        }
        if (fromCode) inputLang.value = fromCode;
        if (toCode) outputLang.value = toCode;
        inputText.value = phrase;
        await translateAndSpeak();
        return;
      }
  
      const translateRegex = /(translate|say|how do you say) (.+?)( to | into | in )([a-z]+)/i;
      match = spokenText.match(translateRegex);
      if (match && match[2]) {
        let phrase = match[2].trim();
        let userLang = match[4];
        if (userLang) {
          for (const [code, name] of Object.entries(langMap)) {
            if (name.toLowerCase().includes(userLang.toLowerCase())) {
              outputLang.value = code;
            }
          }
        }
        inputText.value = phrase;
        await translateAndSpeak();
        return;
      }
  
      const changeLangRegex = /(change|set|switch)( (target|output))? language (to|into|as)?\\s*([a-z]+)/i;
      match = spokenText.match(changeLangRegex);
      if (match) {
        const userLang = match[5];
        for (const [code, name] of Object.entries(langMap)) {
          if (name.toLowerCase().includes((userLang||'').toLowerCase())) {
            outputLang.value = code;
            speak(`Target language changed to ${name}`, inputLang.value);
            return;
          }
        }
        speak("Sorry, I couldn't find that language.", inputLang.value);
        return;
      }
  
      if (/stop (assistant|listening|bot)/i.test(spokenText)) {
        speak("Stopping assistant. Goodbye.", inputLang.value);
        stopAssistant();
        return;
      }
  
      inputText.value = spokenText;
      await translateAndSpeak();
    }
  
    async function translateAndSpeak() {
      const text = inputText.value.trim();
      const targetLanguage = outputLang.value;
      translatedText.innerText = "";
      if (!text) return;
      try {
        const res = await fetch('https://nova-translator-backend.onrender.com/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, targetLanguage })
        });
        const data = await res.json();
        if (data.translatedText) {
          translatedText.innerText = data.translatedText;
          speak(data.translatedText, targetLanguage);
        } else {
          translatedText.innerText = "Translation failed: " + (data.error || "Unknown error");
          speak("Sorry, translation failed.", inputLang.value);
        }
      } catch (err) {
        translatedText.innerText = "Network or server error: " + err.message;
        speak("Sorry, network or server error.", inputLang.value);
      }
    }
  
    function speak(text, lang) {
      if ('speechSynthesis' in window && text) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = langCodeMap[lang] || lang || "en-US";
        utter.rate = 1.03;
        utter.volume = 1;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utter);
      }
    }
  
    speakBtn.onclick = () => { speak(translatedText.innerText, outputLang.value); };
    clearBtn.onclick = () => {
      inputText.value = '';
      translatedText.innerText = '';
      inputText.focus();
    };
  
    inputText.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        translateAndSpeak();
      }
    });
  </script>
  
</body>
</html>
