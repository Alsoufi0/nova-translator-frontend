<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nova Voice Translator | ZOX Robotics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="zox-logo.png">
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #2dd2ff 0%, #9447ff 100%);
      min-height: 100vh;
      color: #fff;
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
      margin: 0; padding: 0;
    }
    .logo-bar { margin-top: 1.4em; margin-bottom: 0.5em; width: 100vw; display: flex; justify-content: center; }
    .logo-bar img { width: 120px; border-radius: 15px; box-shadow: 0 2px 12px #13f5ff66; background: #fff; padding: 0.3em 1.2em 0.1em 1.2em; }
    .container { width: 97vw; max-width: 700px; background: rgba(15,22,60,0.96); border-radius: 32px; box-shadow: 0 8px 32px #00fff355, 0 4px 16px #0005; padding: 2.3em 1.5em 2em 1.5em; margin: 0 auto; border: 2.5px solid #21c8ff33; display: flex; flex-direction: column; align-items: center; }
    h2 { font-size: 2.1rem; font-weight: 900; margin-bottom: 0.6em; letter-spacing: 2px; background: linear-gradient(90deg, #21c8ff 13%, #ff6ae7 93%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; margin-top: 0; }
    .label { color: #2cffb9; font-weight: 700; font-size: 1.1rem; margin-bottom: 0.2em; letter-spacing: 0.01em; }
    .row { display: flex; width: 100%; gap: 1.1em; align-items: flex-start; justify-content: center; margin-bottom: 1.2em; }
    .lang-panel { flex: 1; min-width: 170px; max-width: 310px; background: linear-gradient(115deg, #232a55 60%, #382a67 100%); padding: 1em 1em 1.2em 1em; border-radius: 22px; box-shadow: 0 2px 10px #4ff9ff13; border: 2px solid #5ad0fd24; min-height: 120px; }
    select { width: 100%; padding: 0.42em 0.8em; border-radius: 11px; border: 1.4px solid #28f3e988; background: #232e48; color: #fff; font-size: 1rem; font-weight: 700; outline: none; }
    textarea, .output-box { width: 100%; border-radius: 13px; font-size: 1.08rem; background: #192241; color: #fff; border: none; padding: 1em 1em; box-shadow: 0 2px 8px #00fff314; outline: none; transition: box-shadow 0.2s; resize: none; min-height: 65px; font-weight: 500; }
    .output-box { background: #171b33; border: 2px solid #00f2ff18; font-weight: 800; text-shadow: 0 1px 7px #00f8ff13; min-height: 65px; display: flex; align-items: center; font-size: 1.1rem; }
    .btn-row { display: flex; width: 100%; justify-content: center; gap: 1em; margin-top: 1em; margin-bottom: 0.25em; flex-wrap: wrap; }
    .main-btn, .mic-btn, .clear-btn, .speak-btn, .auto-btn { padding: 0.67em 1.15em; font-size: 1.03rem; font-weight: 800; border: none; border-radius: 12px; background: linear-gradient(90deg, #21c8ff 33%, #ff6ae7 100%); color: #fff; cursor: pointer; box-shadow: 0 1px 7px #00fff44a; transition: background 0.16s, transform 0.11s; margin-bottom: 0.08em; margin-right: 0.09em; outline: none; font-family: inherit; }
    .auto-btn { background: linear-gradient(120deg,#fffc7a 10%, #21c8ff 85%); color: #181c38; font-size: 1.05em; font-weight: 900; }
    .mic-btn { background: linear-gradient(120deg,#2cffb9 10%, #21c8ff 85%); color: #181c38; font-size: 1.2em; font-weight: 900; box-shadow: 0 0 13px #00ffd7aa; }
    .speak-btn { background: linear-gradient(120deg, #ffd52c 40%, #21c8ff 100%); color: #191b2d; font-weight: 900; font-size: 1.1em; box-shadow: 0 0 13px #a7f61b55; }
    .clear-btn { background: linear-gradient(120deg, #ff607a 55%, #ff6ae7 100%); color: #fff; font-weight: 900; box-shadow: 0 0 8px #ff7091a8; }
    @media (max-width: 800px) { .row { flex-direction: column; gap: 1.2em; } .container { padding: 0.5em 0.2em; border-radius: 0; } }
  </style>
</head>
<body>
  <div class="logo-bar">
    <img src="zox-logo.png" alt="ZOX Robotics Logo">
  </div>
  <div class="container">
    <h2>Nova Voice Translator</h2>
    <div class="row">
      <div class="lang-panel">
        <div class="label">Input Language</div>
        <select id="inputLang">
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="zh">Chinese (Simplified)</option>
          <option value="hi">Hindi</option>
          <option value="ar">Arabic</option>
          <option value="ru">Russian</option>
          <option value="ja">Japanese</option>
          <option value="pt">Portuguese</option>
          <option value="it">Italian</option>
        </select>
        <textarea id="inputText" placeholder="Type or speak..."></textarea>
      </div>
      <div class="lang-panel">
        <div class="label">Target Language</div>
        <select id="outputLang">
          <option value="es">Spanish</option>
          <option value="en">English</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="zh">Chinese (Simplified)</option>
          <option value="hi">Hindi</option>
          <option value="ar">Arabic</option>
          <option value="ru">Russian</option>
          <option value="ja">Japanese</option>
          <option value="pt">Portuguese</option>
          <option value="it">Italian</option>
        </select>
        <div id="translatedText" class="output-box"></div>
      </div>
    </div>
    <div class="btn-row">
      <button class="auto-btn" id="autoListenBtn">Start Assistant</button>
      <button class="clear-btn" id="clearBtn" title="Clear All">Clear</button>
      <button class="speak-btn" id="speakBtn" title="Speak Output">ðŸ”Š</button>
    </div>
    <div style="font-size:0.92em;color:#8ff; margin-top:0.8em; text-align:center;">
      Say: <b>Translate "hello" to Arabic</b> or <b>Change language to French</b> or just speak what you want translated.<br>
      <span style="color:#ffa;">(Give mic access when asked!)</span>
    </div>
  </div>
  <script>
    const langMap = {
      en: "English", es: "Spanish", fr: "French", de: "German", zh: "Chinese (Simplified)", hi: "Hindi",
      ar: "Arabic", ru: "Russian", ja: "Japanese", pt: "Portuguese", it: "Italian"
    };
    const langCodeMap = {
      en: "en-US", es: "es-ES", fr: "fr-FR", de: "de-DE", zh: "zh-CN", hi: "hi-IN",
      ar: "ar-SA", ru: "ru-RU", ja: "ja-JP", pt: "pt-PT", it: "it-IT"
    };
    const inputLang = document.getElementById('inputLang');
    const outputLang = document.getElementById('outputLang');
    const inputText = document.getElementById('inputText');
    const translatedText = document.getElementById('translatedText');
    const clearBtn = document.getElementById('clearBtn');
    const speakBtn = document.getElementById('speakBtn');
    const autoListenBtn = document.getElementById('autoListenBtn');
  
    let recognition = null;
    let isListening = false;
  
    // Voice Assistant Core
    function startAssistant() {
      if (!('webkitSpeechRecognition' in window)) {
        alert('Speech recognition not supported in this browser.');
        return;
      }
      if (recognition) {
        recognition.abort();
        recognition = null;
      }
      recognition = new webkitSpeechRecognition();
      recognition.lang = langCodeMap[inputLang.value] || "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      isListening = true;
  
      autoListenBtn.textContent = "Assistant Listening... (Click to stop)";
      autoListenBtn.classList.add('active');
      autoListenBtn.disabled = false;
  
      recognition.onresult = async (event) => {
        const spokenText = event.results[0][0].transcript.trim();
        await processVoiceCommand(spokenText);
        // Wait until speaking is done, then listen again
        if (isListening) {
          waitForSpeechEnd().then(() => {
            if (isListening) setTimeout(() => recognition.start(), 400);
          });
        }
      };
      recognition.onend = () => {
        // Only auto-restart if assistant is active
        if (isListening && !window.speechSynthesis.speaking) {
          setTimeout(() => recognition.start(), 400);
        }
      };
      recognition.onerror = (event) => {
        if (event.error !== "no-speech" && event.error !== "aborted") {
          alert("Speech error: " + event.error);
        }
        if (isListening) {
          setTimeout(() => recognition.start(), 700);
        }
      };
      recognition.start();
    }
  
    function stopAssistant() {
      isListening = false;
      if (recognition) recognition.abort();
      autoListenBtn.textContent = "Start Assistant";
      autoListenBtn.classList.remove('active');
      autoListenBtn.disabled = false;
    }
  
    autoListenBtn.onclick = () => {
      if (isListening) {
        stopAssistant();
      } else {
        startAssistant();
      }
    };
  
    // Wait until all TTS speech finishes
    function waitForSpeechEnd() {
      return new Promise(resolve => {
        if (!('speechSynthesis' in window)) return resolve();
        if (!window.speechSynthesis.speaking) return resolve();
        let id = setInterval(() => {
          if (!window.speechSynthesis.speaking) {
            clearInterval(id);
            resolve();
          }
        }, 100);
      });
    }
  
    // Voice Command Parsing + Actions
    async function processVoiceCommand(spokenText) {
  // 1. "translate <PHRASE> from <LANG1> to <LANG2>"
  const fromToRegex = /translate (.+?) from ([a-z\s]+) to ([a-z\s]+)/i;
  let match = spokenText.match(fromToRegex);
  if (match) {
    const phrase = match[1].trim();
    const fromLangRaw = match[2].trim();
    const toLangRaw = match[3].trim();
    let fromCode = null, toCode = null;

    // Robust matching for language names
    for (const [code, name] of Object.entries(langMap)) {
      if (name.toLowerCase().includes(fromLangRaw.toLowerCase()) || fromLangRaw.toLowerCase().includes(name.toLowerCase())) fromCode = code;
      if (name.toLowerCase().includes(toLangRaw.toLowerCase()) || toLangRaw.toLowerCase().includes(name.toLowerCase())) toCode = code;
    }
    if (fromCode) inputLang.value = fromCode;
    if (toCode) outputLang.value = toCode;
    inputText.value = phrase;
    if (fromCode && toCode) {
      speak(`Input language set to ${langMap[fromCode]}, target language set to ${langMap[toCode]}.`, inputLang.value);
    }
    await translateAndSpeak();
    return;
  }

  // 2. "translate ... to <LANG2>"
  const translateRegex = /(translate|say|how do you say) (.+?)( to | into | in )([a-z\s]+)$/i;
  match = spokenText.match(translateRegex);
  if (match && match[2]) {
    let phrase = match[2].trim();
    let userLang = match[4].trim();
    if (userLang) {
      for (const [code, name] of Object.entries(langMap)) {
        if (name.toLowerCase().includes(userLang.toLowerCase()) || userLang.toLowerCase().includes(name.toLowerCase())) {
          outputLang.value = code;
          speak(`Target language set to ${name}.`, inputLang.value);
        }
      }
    }
    inputText.value = phrase;
    await translateAndSpeak();
    return;
  }

  // 3. "change language to <LANG2>"
  const changeLangRegex = /(change|set|switch)( (target|output))? language (to|into|as)?\s*([a-z\s]+)/i;
  match = spokenText.match(changeLangRegex);
  if (match) {
    const userLang = match[6]?.trim();
    for (const [code, name] of Object.entries(langMap)) {
      if (name.toLowerCase().includes(userLang.toLowerCase()) || userLang.toLowerCase().includes(name.toLowerCase())) {
        outputLang.value = code;
        speak(`Target language changed to ${name}.`, inputLang.value);
        return;
      }
    }
    speak("Sorry, I couldn't find that language.", inputLang.value);
    return;
  }

  // 4. "change input language to <LANG1>"
  const changeInputLangRegex = /(change|set|switch) input language (to|into|as)?\s*([a-z\s]+)/i;
  match = spokenText.match(changeInputLangRegex);
  if (match) {
    const userLang = match[3]?.trim();
    for (const [code, name] of Object.entries(langMap)) {
      if (name.toLowerCase().includes(userLang.toLowerCase()) || userLang.toLowerCase().includes(name.toLowerCase())) {
        inputLang.value = code;
        speak(`Input language changed to ${name}.`, inputLang.value);
        return;
      }
    }
    speak("Sorry, I couldn't find that input language.", inputLang.value);
    return;
  }

  // 5. "stop assistant"
  if (/stop (assistant|listening|bot)/i.test(spokenText)) {
    speak("Stopping assistant. Goodbye.", inputLang.value);
    stopAssistant();
    return;
  }

  // 6. Just treat as text to translate
  inputText.value = spokenText;
  await translateAndSpeak();
}

  
    async function translateAndSpeak() {
      const text = inputText.value.trim();
      const targetLanguage = outputLang.value;
      translatedText.innerText = ""; // clear first
      if (!text) return;
      try {
        const res = await fetch('https://nova-translator-backend.onrender.com/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, targetLanguage })
        });
        const data = await res.json();
        if (data.translatedText) {
          translatedText.innerText = data.translatedText;
          speak(data.translatedText, targetLanguage);
        } else {
          translatedText.innerText = "Translation failed: " + (data.error || "Unknown error");
          speak("Sorry, translation failed.", inputLang.value);
        }
      } catch (err) {
        translatedText.innerText = "Network or server error: " + err.message;
        speak("Sorry, network or server error.", inputLang.value);
      }
    }
  
    function speak(text, lang) {
      if ('speechSynthesis' in window && text) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = langCodeMap[lang] || lang || "en-US";
        utter.rate = 1.03;
        utter.volume = 1;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utter);
      }
    }
  
    speakBtn.onclick = () => { speak(translatedText.innerText, outputLang.value); };
    clearBtn.onclick = () => {
      inputText.value = '';
      translatedText.innerText = '';
      inputText.focus();
    };
  
    // Optionally: Listen for ENTER key to trigger translation (desktop)
    inputText.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        translateAndSpeak();
      }
    });
  
    // Optional: Start assistant immediately if desired (but requires user gesture per browser rules)
    // window.onload = () => { startAssistant(); };
  </script>
  
  

</body>
</html>
